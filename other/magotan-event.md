# 前端埋点中的一些坑


## 用户信息绑定
在埋点统计中很难避免要记录并且区分某个用户的一系列行为。这些行为统计在一起就是一个数据漏斗。

例如：
一个线上课程，要统计用户从访问投放页面到开通课程的整个过程的漏斗数据，并且要去除重复数据、区分出新老用户：

这个时候我们至少要记录到一个用户的以下行为：

- 访问投放页面
- 下单
- 支付
- 开通课程

这些打点事件并不是发生在同一个页面中，也有可能不是同一个时间段内发生的。为了实现`去重`、`区分用户`，我们就要在打点数据中添加标识。

这里我们经历了两个阶段

### 第一个阶段

后端生成 一个 `gid` ，并且在用户登录时返回到前端，前端存储在localstorage 中，每次打点带上。数据平台根据`gid`匹配用户。

缺点：
- 每次进入页面要请求登录接口（微信内页面涉及到静默授权）。在小程序环境和h5都更倾向于登录后置，由用户触发的处理方案。
- 事件有可能缺失`gid`，例如： 进入页面的goPage、未登录之前记录的事件
- 在基于事件重发机制的情况下，有部分事件没有携带`gid`，会导致相同的行为事件，`gid`不同。（去重失效）

### 第二阶段

基于第一阶段的一些缺点，这里对用户绑定进行了改造。

-  由前端SDK 生成随机的 `clientId`，作为用户客户端的唯一标识，并且 `clientId`会随着登录token 的改变重新生成（避免同一个clientId 绑定多个user）。
- 当触发埋点时，获取当前的用户信息。当存在用户信息时，埋点信息内添加用户的`userId`,；当不存在用户信息时（未登录），埋点信息内`userId` 为空。
- 数据平台接收到埋点信息后，会根据 clientId 和 userId 来绑定用户。这样用户的一些列行为就可以跟踪了。


## 埋点事件的管理
遇到对的问题：

原始的埋点事件中，大部分的业务事件的埋点都是在根据需求由开发同学在代码中埋入。

随着时间推移，需求不断增加，业务埋点也越来越多，就出现了业务埋点难以管理的问题。之前的埋点只有当时的产品和熟悉这条业务线的开发知晓，对于其他人很难知道到底哪个部分埋了哪些点。

基于上边的问题，埋点的方案也随之优化。

方案：

1. 搭建埋点事件管理后台（Stein ），当有需求要新增埋点时，需要在后台注册新的event 事件，并且规定需要的数据格式，随之生成一个 eventCode。
2. 开发在代码中调用打点事件时传入 eventCode。
3. 数据接收到埋点发送的事件时，将信息记录到对应的eventCode下。



